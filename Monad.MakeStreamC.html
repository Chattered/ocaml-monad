<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Monad.MakeStream.html">
<link rel="next" href="Monad.LazyT.html">
<link rel="Up" href="Monad.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="TagTree" rel="Chapter" href="TagTree.html">
<link title="Monad" rel="Chapter" href="Monad.html">
<link title="Applicative" rel="Chapter" href="Applicative.html"><title>Monad.MakeStreamC</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Monad.MakeStream.html" title="Monad.MakeStream">Previous</a>
&nbsp;<a class="up" href="Monad.html" title="Monad">Up</a>
&nbsp;<a class="post" href="Monad.LazyT.html" title="Monad.LazyT">Next</a>
</div>
<h1>Functor <a href="type_Monad.MakeStreamC.html">Monad.MakeStreamC</a></h1>
<pre><span class="keyword">module</span> MakeStreamC: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span class="keyword">include</span> Monad.BaseCollectionM</pre>
<pre><span class="keyword">include</span> Applicative.Base</pre>
</div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.MakeStreamC.html">..</a> <code class="code">end</code></div></pre><div class="info">
Here, we create a stream monad from a definite collection monad <a href="Monad.BaseCollectionM.html"><code class="code">Monad.BaseCollectionM</code></a>. The inner monad will be used to represent the
    generations in the stream. The order of elements in each generation should
    not matter, so you might want to use a set or a bag. If you want to live
    life on the edge, just remember that your code should not depend on the
    order of elements within generations (you can, of course, depend on the
    order that generations appear in the stream). You can enforce this
    constraint by performing, say, a sort on each generation.<br>
</div>
<table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%">
<code>M</code></td>
<td align="center" valign="top">:</td>
<td><code class="type">sig
    include BaseCollectionM
    include <a href="Applicative.Base.html">Applicative.Base</a> with type 'a m := 'a m
end</code>
</table>
</td>
</tr>
</table>
<hr width="100%">
<pre><span class="keyword">include</span> <a href="Monad.StreamC.html">Monad.StreamC</a></pre>
<pre><span class="keyword">include</span> <a href="Applicative.Base.html">Applicative.Base</a></pre>
</body></html>