<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="TagTree.html">
<link rel="next" href="Applicative.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="TagTree" rel="Chapter" href="TagTree.html">
<link title="Monad" rel="Chapter" href="Monad.html">
<link title="Applicative" rel="Chapter" href="Applicative.html"><link title="Base Modules" rel="Section" href="#6_BaseModules">
<link title="Some general monads." rel="Section" href="#6_Somegeneralmonads">
<link title="Library Types " rel="Section" href="#6_LibraryTypes">
<link title="Library Creation" rel="Section" href="#6_LibraryCreation">
<link title="Specific monads" rel="Section" href="#6_Specificmonads">
<link title="Transformers" rel="Section" href="#6_Transformers">
<link title="Transformers on Collections " rel="Section" href="#6_TransformersonCollections">
<title>Monad</title>
</head>
<body>
<div class="navbar"><a class="pre" href="TagTree.html" title="TagTree">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Applicative.html" title="Applicative">Next</a>
</div>
<h1>Module <a href="type_Monad.html">Monad</a></h1>
<pre><span class="keyword">module</span> Monad: <code class="code">sig</code> <a href="Monad.html">..</a> <code class="code">end</code></pre><div class="info">
The monad library.
<p>

    <b>Introduction</b>
<p>

    Monads are a popular concept in Haskell and controversial just about
    everywhere else on the planet! They have been thought of by some in the
    Ocaml community as a "design pattern" (see the documentation for
    BatMonad), and a nice way to abstract over resource manipulation. My
    favourite example in Ocaml is the lwt library.
<p>

    But I find that, in Ocaml, "monads" are typically seen rather narrowly in
    terms of a bind and return function. Personally, I think monads are bigger
    than that. They are an <i>abstraction</i>, and the meaning of that abstraction
    is to be found in libraries which give you general functions that apply to
    <i>all</i> monads. To make the point concretely, if we aren't automatically
    deriving a <a href="Monad.Monad.html#VALjoin"><code class="code">Monad.Monad.join</code></a> function for all of our monads, then we've missed
    something important.
<p>

    In other words, I want to say that monads as an abstraction are defined by
    an abstract monad <i>library</i>. Such a library is the purpose of this
    module.
<p>

    I recommend checking out the the types in this module. I find they say a <i>    lot</i> about the meaning of the various functions.
<p>

    <b>A rambling note on terminology </b>
<p>

    There's some confusing terminology when it comes to monads, which I'll try
    to clarify for the purposes of the documentation.
<p>

    Now I'm no category theorist, but if I were to try to get technical, I'd
    say that a monad is a three-tuple: a type-constructor, and two
    functions. So, for instance, the list monad can be defined by three things:
<p>
<ul>
<li>the constructor <code class="code">list</code> which appears in type expressions such as <code class="code">'a list</code>;</li>
<li>the function <code class="code">return</code>;</li>
<li>the function <code class="code">bind</code>.</li>
</ul>

    The fact that we have a type-constructor here explains why a monad cannot
    be represented nicely by a simple tuple. We need to package them into a
    module instead.
<p>

    Terminology now gets a bit hairy, because as pointed out by
    <a href="http://blog.plover.com/prog/haskell/monad-terminology.html"> Mark
    Dominus</a>, we need to talk about many different things in the context of
    monads, which leads to overloading and an (overused) use of the adjective
    "monadic."
<p>

    We have our three tuple above, we have the type-constructor <code class="code">list</code>, we have
    types such as <code class="code">int list</code>, and we have values such as <code class="code">[1;2;3] : int
    list</code>. In general, I shall reserve "monad" for the type-constructor
    <code class="code">list</code>, and I'll read values such as <code class="code">[1;2;3]</code> as "the computation in the
    <code class="code">list</code> monad which returns 1, 2 or 3." I will also read values of type <code class="code">m
    ()</code> as "the computation in the <code class="code">m</code> monad which returns nothing."
<p>

    I'm not convinced that "computation" is the best analogy for what monads
    are about, and I worry that if this metaphor gets taken too seriously,
    we might miss some interesting monads. For now, I'm just treating it
    as a useful metaphor for writing this documentation.<br>
<b>Author(s):</b> Phil Scott<br>
</div>
<hr width="100%">
<br>
<h6 id="6_BaseModules">Base Modules</h6><br>
<pre><span class="keyword">module type</span> <a href="Monad.Monoid.html">Monoid</a> = <code class="code">sig</code> <a href="Monad.Monoid.html">..</a> <code class="code">end</code></pre><div class="info">
This is your usual monoid.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.BasePlus.html">BasePlus</a> = <code class="code">sig</code> <a href="Monad.BasePlus.html">..</a> <code class="code">end</code></pre><div class="info">
Monads with additional monoid structure.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.BaseLazyPlus.html">BaseLazyPlus</a> = <code class="code">sig</code> <a href="Monad.BaseLazyPlus.html">..</a> <code class="code">end</code></pre><div class="info">
LazyPlus is another base module useful when the monad is a lazy data
    structure.
</div>
<br>
<h6 id="6_Somegeneralmonads">Some general monads.</h6><br>
<pre><span class="keyword">module type</span> <a href="Monad.Reader.html">Reader</a> = <code class="code">sig</code> <a href="Monad.Reader.html">..</a> <code class="code">end</code></pre><div class="info">
Readers are monads which allow computations to depend on a fixed
    environment.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.Writer.html">Writer</a> = <code class="code">sig</code> <a href="Monad.Writer.html">..</a> <code class="code">end</code></pre><div class="info">
A writer allows an additional output value to be written during
    computations and accumulated into a final result.
</div>
<pre><span class="keyword">module</span> <a href="Monad.State.html">State</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="TYPEs"><span class="keyword">type</span> <code class="type"></code>s</span> </pre>

</div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.State.html">..</a> <code class="code">end</code></div></pre><div class="info">
State monads.
</div>
<pre><span class="keyword">module</span> <a href="Monad.Error.html">Error</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">E</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="TYPEe"><span class="keyword">type</span> <code class="type"></code>e</span> </pre>

<pre><span id="VALdefaultError"><span class="keyword">val</span> defaultError</span> : <code class="type">e</code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.Error.html">..</a> <code class="code">end</code></div></pre><div class="info">
Error monads.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.BaseCollectionM.html">BaseCollectionM</a> = <code class="code">sig</code> <a href="Monad.BaseCollectionM.html">..</a> <code class="code">end</code></pre><div class="info">
Monads for collections.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.Stream.html">Stream</a> = <code class="code">sig</code> <a href="Monad.Stream.html">..</a> <code class="code">end</code></pre><div class="info">
Streams supporting fair and unbounded search.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.StreamC.html">StreamC</a> = <code class="code">sig</code> <a href="Monad.StreamC.html">..</a> <code class="code">end</code></pre><div class="info">
The union of streams and collections.
</div>
<br>
<h6 id="6_LibraryTypes">Library Types </h6><br>
<pre><span class="keyword">module type</span> <a href="Monad.Monad.html">Monad</a> = <code class="code">sig</code> <a href="Monad.Monad.html">..</a> <code class="code">end</code></pre><div class="info">
Your basic library functions for monads.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.MonadPlus.html">MonadPlus</a> = <code class="code">sig</code> <a href="Monad.MonadPlus.html">..</a> <code class="code">end</code></pre><div class="info">
Library functions for monads with additional monoid structure.
</div>
<pre><span class="keyword">module type</span> <a href="Monad.LazyPlus.html">LazyPlus</a> = <code class="code">sig</code> <a href="Monad.LazyPlus.html">..</a> <code class="code">end</code></pre><div class="info">
This is the counterpart for the lazy version of <a href="Monad.BasePlus.html"><code class="code">Monad.BasePlus</code></a>.
</div>
<br>
<h6 id="6_LibraryCreation">Library Creation</h6><br>
<br>
Use these functors with the base modules to generate the monad library functions.<br>
<pre><span class="keyword">module</span> <a href="Monad.Make.html">Make</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type">BatInterfaces.Monad</code><code class="code">) -&gt; </code><code class="type"><a href="Monad.Monad.html">Monad</a></code><code class="type">  with type 'a m = 'a M.m</code></div></pre><div class="info">
Monad library.
</div>
<pre><span class="keyword">module</span> <a href="Monad.MakePlus.html">MakePlus</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type"><a href="Monad.BasePlus.html">BasePlus</a></code><code class="code">) -&gt; </code><code class="type"><a href="Monad.MonadPlus.html">MonadPlus</a></code><code class="type">  with type 'a m = 'a M.m</code></div></pre><div class="info">
MonadPlus library.
</div>
<pre><span class="keyword">module</span> <a href="Monad.MakeLazyPlus.html">MakeLazyPlus</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type"><a href="Monad.BaseLazyPlus.html">BaseLazyPlus</a></code><code class="code">) -&gt; </code><code class="type"><a href="Monad.LazyPlus.html">LazyPlus</a></code><code class="type">  with type 'a m = 'a M.m</code></div></pre><div class="info">
LazyPlus library.
</div>
<br>
<h6 id="6_Specificmonads">Specific monads</h6><br>
<pre><span class="keyword">module</span> <a href="Monad.LazyM.html">LazyM</a>: <code class="type">BatInterfaces.Monad</code><code class="type">  with type 'a m = 'a Lazy.t</code></pre><div class="info">
The lazy monad.
</div>
<pre><span class="keyword">module</span> <a href="Monad.List.html">List</a>: <code class="type"><a href="Monad.BasePlus.html">BasePlus</a></code><code class="type">  with type 'a m = 'a list</code></pre><div class="info">
The venerable list monad.
</div>
<pre><span class="keyword">module</span> <a href="Monad.LazyListM.html">LazyListM</a>: <code class="type"><a href="Monad.BaseLazyPlus.html">BaseLazyPlus</a></code><code class="type">  with type 'a m = 'a LazyList.t</code></pre><div class="info">
The lazy list monad.
</div>
<pre><span class="keyword">module</span> <a href="Monad.Option.html">Option</a>: <code class="type"><a href="Monad.BasePlus.html">BasePlus</a></code><code class="type">  with type 'a m = 'a option</code></pre><div class="info">
Options can be understood as computations which might optionally fail.
</div>
<pre><span class="keyword">module</span> <a href="Monad.Continuation.html">Continuation</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="TYPEr"><span class="keyword">type</span> <code class="type"></code>r</span> </pre>

</div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.Continuation.html">..</a> <code class="code">end</code></div></pre><div class="info">
The continuation monad.
</div>
<pre><span class="keyword">module</span> <a href="Monad.MakeReader.html">MakeReader</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>

</div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.MakeReader.html">..</a> <code class="code">end</code></div></pre><div class="info">
Create a reader from an arbitrary type of environment.
</div>
<pre><span class="keyword">module</span> <a href="Monad.MakeWriter.html">MakeWriter</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type"><a href="Monad.Monoid.html">Monoid</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.MakeWriter.html">..</a> <code class="code">end</code></div></pre><div class="info">
Create a writer from an arbitrary type of written value.
</div>
<pre><span class="keyword">module</span> <a href="Monad.MakeStream.html">MakeStream</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span class="keyword">include</span> Monad.BaseLazyPlus</pre>
<pre><span class="keyword">include</span> Applicative.Base</pre>
</div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.MakeStream.html">..</a> <code class="code">end</code></div></pre><div class="info">
Create a stream monad from an arbitrary inner monad, which computes the
    values discovered in each generation.
</div>
<pre><span class="keyword">module</span> <a href="Monad.MakeStreamC.html">MakeStreamC</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span class="keyword">include</span> Monad.BaseCollectionM</pre>
<pre><span class="keyword">include</span> Applicative.Base</pre>
</div><code class="code">end</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.MakeStreamC.html">..</a> <code class="code">end</code></div></pre><div class="info">
Here, we create a stream monad from a definite collection monad <a href="Monad.BaseCollectionM.html"><code class="code">Monad.BaseCollectionM</code></a>.
</div>
<br>
<h6 id="6_Transformers">Transformers</h6><br>
<br>
Monads support a certain amount of composition, allowing one create a
    single monad which combines the properties of other monads. For instance,
    we might want a monad which reads from an environment and writes to a
    log. We can do this by transforming the reader monad with the writer
    transformer, or vice versa.<br>
<pre><span class="keyword">module</span> <a href="Monad.LazyT.html">LazyT</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type">BatInterfaces.Monad</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.LazyT.html">..</a> <code class="code">end</code></div></pre><div class="info">
The lazy monad transformer will wrap computated values in a thunk.
</div>
<pre><span class="keyword">module</span> <a href="Monad.ListT.html">ListT</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type">BatInterfaces.Monad</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.ListT.html">..</a> <code class="code">end</code></div></pre><div class="info">
The list monad transformer will add non-determinism to computations.
</div>
<pre><span class="keyword">module</span> <a href="Monad.OptionT.html">OptionT</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type">BatInterfaces.Monad</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.OptionT.html">..</a> <code class="code">end</code></div></pre><div class="info">
The option monad transformer will allow computations to fail.
</div>
<pre><span class="keyword">module</span> <a href="Monad.StateT.html">StateT</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="TYPEs"><span class="keyword">type</span> <code class="type"></code>s</span> </pre>

</div><code class="code">end</code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type">BatInterfaces.Monad</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.StateT.html">..</a> <code class="code">end</code></div></div></pre><div class="info">
The state monad transformer will allow computations to read and write to a state.
</div>
<pre><span class="keyword">module</span> <a href="Monad.WriterT.html">WriterT</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">W</code><code class="code"> : </code><code class="type"><a href="Monad.Writer.html">Writer</a></code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">M</code><code class="code"> : </code><code class="type">BatInterfaces.Monad</code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.WriterT.html">..</a> <code class="code">end</code></div></div></pre><div class="info">
The writer monad transformer will allow computations to write values.
</div>
<br>
<h6 id="6_TransformersonCollections">Transformers on Collections </h6><br>
<br>
Sometimes, you might want to transform a collection monad, in such a way
    that functions such as <a href="Monad.BaseCollectionM.html#VALunique"><code class="code">Monad.BaseCollectionM.unique</code></a> behave in a sensible
    way by regarding None as smaller than any Some. Each transformer provides
    a function <code class="code">cmp_on</code> with which the collection functions such as
    <code class="code">BaseCollectionM.difference</code> are implemented. We also provide the <code class="code">list</code>
    function for transformers.<br>
<pre><span class="keyword">module</span> <a href="Monad.CollectionOpt.html">CollectionOpt</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">C</code><code class="code"> : </code><code class="type"><a href="Monad.BaseCollectionM.html">BaseCollectionM</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.CollectionOpt.html">..</a> <code class="code">end</code></div></pre><div class="info">
Transformer allowing optional values in a collection.
</div>
<pre><span class="keyword">module</span> <a href="Monad.CollectionWriter.html">CollectionWriter</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">W</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span class="keyword">include</span> Monad.Writer</pre>
<pre><span id="VALcmp"><span class="keyword">val</span> cmp</span> : <code class="type">t -> t -> bool</code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">C</code><code class="code"> : </code><code class="type"><a href="Monad.BaseCollectionM.html">BaseCollectionM</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.CollectionWriter.html">..</a> <code class="code">end</code></div></div></pre><div class="info">
Transformer for writing data inside a collection.
</div>
<pre><span class="keyword">module</span> <a href="Monad.CollectionState.html">CollectionState</a>: <div class="sig_block"><code class="code">functor (</code><code class="code">T</code><code class="code"> : </code><code class="code">sig</code><div class="sig_block"><pre><span id="TYPEs"><span class="keyword">type</span> <code class="type"></code>s</span> </pre>

<pre><span id="VALcmp"><span class="keyword">val</span> cmp</span> : <code class="type">s -> s -> bool</code></pre></div><code class="code">end</code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">C</code><code class="code"> : </code><code class="type"><a href="Monad.BaseCollectionM.html">BaseCollectionM</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Monad.CollectionState.html">..</a> <code class="code">end</code></div></div></pre><div class="info">
State inside a collection.
</div>
</body></html>