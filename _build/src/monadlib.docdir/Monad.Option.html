<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Monad.LazyListM.html">
<link rel="next" href="Monad.Continuation.html">
<link rel="Up" href="Monad.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="TagTree" rel="Chapter" href="TagTree.html">
<link title="Monad" rel="Chapter" href="Monad.html">
<link title="Applicative" rel="Chapter" href="Applicative.html"><title>Monad.Option</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Monad.LazyListM.html" title="Monad.LazyListM">Previous</a>
&nbsp;<a class="up" href="Monad.html" title="Monad">Up</a>
&nbsp;<a class="post" href="Monad.Continuation.html" title="Monad.Continuation">Next</a>
</div>
<h1>Module <a href="type_Monad.Option.html">Monad.Option</a></h1>
<pre><span class="keyword">module</span> Option: <code class="type"><a href="Monad.BasePlus.html">BasePlus</a></code><code class="type">  with type 'a m = 'a option</code></pre><div class="info">
Options can be understood as computations which might optionally fail. You
    might ordinarily use exceptions for this, but options have the nice
    advantage that they are data! You can package them up into lists, and use
    generic library functions such as <code class="code">Applicative.sequence</code> to compute
    either a list of successful return values, or a failure if any of the individual
    computations fails.
<p>

    There is already precedent for moving away from exceptions and towards
    options. See the Exceptionless modules in batteries, and consider that
    it is becoming popular to wrap nullable values in F# and Scala with options
    and thus warn against the dreaded null-pointer exception.
<p>

    The plus operation of option will discard the right-hand computation if
    both return values.<br>
</div>
<hr width="100%">
<pre><span class="keyword">include</span> BatInterfaces.Monad</pre>
<pre><span id="VALzero"><span class="keyword">val</span> zero</span> : <code class="type">unit -> 'a m</code></pre><pre><span id="VALplus"><span class="keyword">val</span> plus</span> : <code class="type">'a m -> 'a m -> 'a m</code></pre><pre><span id="VALnull"><span class="keyword">val</span> null</span> : <code class="type">'a m -> bool</code></pre><div class="info">
null x implies that x is zero. If you do not want to or cannot
      answer whether a given x is zero, then null x should be false. I have
      provided this so that streams can be implemented more efficiently.<br>
</div>
</body></html>