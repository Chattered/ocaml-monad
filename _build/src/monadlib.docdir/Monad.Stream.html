<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Monad.BaseCollectionM.html">
<link rel="next" href="Monad.StreamC.html">
<link rel="Up" href="Monad.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="LazyList" rel="Chapter" href="LazyList.html">
<link title="TagTree" rel="Chapter" href="TagTree.html">
<link title="Monad" rel="Chapter" href="Monad.html">
<link title="Applicative" rel="Chapter" href="Applicative.html"><title>Monad.Stream</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Monad.BaseCollectionM.html" title="Monad.BaseCollectionM">Previous</a>
&nbsp;<a class="up" href="Monad.html" title="Monad">Up</a>
&nbsp;<a class="post" href="Monad.StreamC.html" title="Monad.StreamC">Next</a>
</div>
<h1>Module type <a href="type_Monad.Stream.html">Monad.Stream</a></h1>
<pre><span class="keyword">module type</span> Stream = <code class="code">sig</code> <a href="Monad.Stream.html">..</a> <code class="code">end</code></pre><div class="info">
Streams supporting fair and unbounded search.
<p>

    Spivey has a nice and authoratitive paper on this, understanding streams as
    a breadth-first search. If that description appeals to you, I recommend his
    paper. Personally, I found it helpful to understand streams a bit
    differently, as concurrent processes that go off and discover data.
<p>

    First, we have <i>generations</i>, which are collections of zero or more
    data. The data in each generation is discovered simultaneously, and
    therefore, it doesn't make much sense to have any ordering imposed on the
    generations. In fact, the lack of an ordering is essential for getting the
    associativity laws of the monad, and is why Spivey's paper works with bags.
<p>

    Now a stream is just a lazy list of generations. We want to think of the
    indices into these streams as temporal indices. So the first generation in
    the lazy list was discovered at time 0. The second was discovered at time
    1. The third was discovered at time 2. And so on.
<p>

    Thinking this way helped me figure out <code class="code">return</code> and <code class="code">join</code>. Here,
    <code class="code">return x</code> gives you the process which immediately discovers <code class="code">x</code> and then
    terminates.
<p>

    With <code class="code">join xss</code>, we should interpret the <code class="code">xss</code> as a process which discovers
    <i>other processes</i>. When we join them, we ask the outer process to fork
    each inner process as soon as it is discovered, and then merge in all the
    values found by the forked processes. For instance, if <code class="code">xs</code> discovers a
    process <code class="code">p</code> at time 5, and in turn, <code class="code">p</code> discovers the string "hello world!"
    at time 13, then <code class="code">join xs</code> discovers "hello world!" at time 5 + 13 = 18.
<p>

    Now we can understand <code class="code">bind</code>, realising that it is just the result of doing
    a <code class="code">map</code> and then a <code class="code">join</code>. The expression <code class="code">bind xs f</code> forks processes <code class="code">f</code>
    which depend on a discovered value <code class="code">x</code>, and then merges back all their values.
<p>

    Technically, all our streams should be infinite, and the processes should
    run forever, but this gave me sad performance in my theorem proving
    code. So for efficiency, our streams can be truncated, which represents a
    process that terminates.
<p>

    Note that it is impossible to define a general <a href="Monad.BaseLazyPlus.html#VALnull"><code class="code">Monad.BaseLazyPlus.null</code></a>
    predicate for streams, because we would have to be able to decide whether
    an infinite stream of values consists entirely of the empty generation. Turing
    says that's impossible, and I believe him. As a crude approximation, then,
    we have it that <a href="Monad.BaseLazyPlus.html#VALnull"><code class="code">Monad.BaseLazyPlus.null</code></a> returns <code class="code">true</code> just for the special case that
    its input is an empty lazy list.<br>
</div>
<hr width="100%">
<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>

<pre><span class="keyword">include</span> <a href="Monad.BaseLazyPlus.html">Monad.BaseLazyPlus</a></pre>
<pre><span id="VALiterate"><span class="keyword">val</span> iterate</span> : <code class="type">('a m -> 'a m) -> 'a m -> 'a m</code></pre><div class="info">
The sum of the stream <code class="code">[f x, f (f x), f (f (f x)),...]</code><br>
</div>
<pre><span id="VALdelay"><span class="keyword">val</span> delay</span> : <code class="type">'a m -> 'a m</code></pre><div class="info">
Delay a stream by one time step. This is needed when you write recursive
  streams and you have to avoid deadlock. The nice thing about Ocaml here is that
  it will generally detect deadlock for you, announcing to you that you're
  writing viciously circular lists!<br>
</div>
<pre><span id="VALto_depth"><span class="keyword">val</span> to_depth</span> : <code class="type">int -> 'a m -> 'a m</code></pre><div class="info">
Terminate discovery at some depth.<br>
</div>
</body></html>